---
inclusion: manual
---

# 线上问题排查指南

快速定位和解决线上问题的实践经验。

---

## 核心原则：BUG 排查 = 需求开发

BUG 排查和需求开发是同一个流程，只是信息输入方式不同：
- 需求开发：用户描述需要什么功能
- BUG 排查：用户描述出现了什么问题

必须遵循复杂开发流程：
```
阶段1：问题澄清 -> research_mode + process_thought -> 分析可能原因
阶段2：确认方案 -> 与用户确认问题原因 -> 得到确认后再修改
阶段3：执行修复 -> 修改代码 -> 验证修复效果
```

---

## 排查原则（必须遵守）

[重要] 禁止猜测
- 不能根据文档示例、历史记录推断实际配置

[重要] 先确认再改
- 任何代码修改前必须与用户确认

[重要] 查实际数据
- 用数据库查询、日志、API 响应验证假设

[重要] 不确定就问
- 无法验证时直接询问用户

[重要] 用 MCP 前先问
- 使用 mysql_query 前先问用户用哪个数据库

错误示例：
```
看到文档中写 iam_global_user -> 直接认为数据库表名是 iam_global_user -> 修改代码
```

正确做法：
```
1. 先问用户：表在哪个数据库？用哪个 mysql_query MCP？
2. 确认后再用 mysql_query 查询验证
3. 或者直接问用户确认实际配置
4. 确认后再修改代码
```

---

## 结论验证原则（反证法）

在得出任何"配置错误"或"代码缺陷"结论前，必须执行反证法检验。

验证步骤：
1. 识别依赖关系：找出依赖同一配置/代码的其他功能
2. 检查功能状态：这些功能是否正常工作？
3. 逻辑验证：
   - 如果其他功能正常 -> 配置/代码本身没问题 -> 排除该假设
   - 如果其他功能也异常 -> 可能是配置/代码问题 -> 继续验证

示例：表名错误假设
```
假设："表名 global_user 错误，应该是 iam_global_user"
依赖该表的功能：查询用户列表、用户登录、用户详情
检查：查询用户列表正常工作
结论：表名配置正确，排除该假设
```

---

## 数据库问题排查原则

发现不一致时，禁止假设任何一方是"正确的"，必须列出所有可疑点让用户确认。

排查步骤：
1. 收集信息：
   - 查看 DDL 脚本（如 init_table.sql）中的定义
   - 用 DESCRIBE table_name 查看实际数据库结构
   - 查看代码中的实体定义和注解
2. 对比差异：列出所有不一致的地方
3. 列出可疑点：不做假设，把所有可能性都列出来
4. 询问用户：让用户确认哪个是正确的设计意图

错误思维（假设某一方是对的）：
```
发现 DDL 定义是 NULL，数据库是 NOT NULL
假设 DDL 是对的 -> 结论：数据库被错误修改
```

正确思维（不假设，列出可疑点）：
```
发现 DDL 定义是 NULL，数据库是 NOT NULL
可疑点 1：DDL 脚本定义错误
可疑点 2：数据库被手动修改过
可疑点 3：有其他迁移脚本修改了表结构
询问用户：设计意图是什么？tenantId 应该允许为空吗？
用户确认后再决定修复方案
```

给出初步分析帮助用户判断：
1. 从业务逻辑角度分析：哪种定义更符合业务场景？
2. 从代码逻辑角度分析：代码是按哪种假设写的？
3. 从注释/文档角度分析：有没有明确说明设计意图？
4. 给出建议：基于分析，推荐哪种修复方案

---

## 500 错误排查流程

步骤 1：尝试获取日志
- 询问用户是否能提供后端日志
- 如果能获取，直接从日志定位问题

步骤 2：无日志时的代码分析（必须使用 task-manager）
```
1. research_mode - 梳理完整调用链，识别所有可能的异常点
2. process_thought - 逐个分析每个异常点的触发条件
3. 产出结论报告 - 列出所有可能原因并排序（按可能性从高到低）
4. 与用户确认 - 确认最可能的原因
5. 确认后修改 - 得到用户确认后再修改代码
```

禁止行为：
- 根据文档示例推断实际配置
- 未确认就修改代码
- 猜测问题原因并直接"修复"
- 跳过 task-manager 思考流程

---

## 常见问题速查

401 Unauthorized
- 可能原因：Token 存储不一致
- 排查方向：检查 Nacos 配置

404 Not Found
- 可能原因：API 路径错误
- 排查方向：检查前端部署版本

500 Internal Error
- 可能原因：后端异常
- 排查方向：查看日志或代码分析

数据不更新/显示旧数据
- 可能原因：浏览器缓存
- 排查方向：URL 加 ?nocache=1

---

## 缓存问题排查

典型场景：修改后数据不更新、页面显示旧内容、接口返回旧数据

快速验证方法：
```
在请求 URL 后添加 ?nocache=1 参数
例如：/api/users -> /api/users?nocache=1
```

排查步骤：
1. 在浏览器 Network 面板查看请求
2. 检查 Response Headers 中的缓存相关头：Cache-Control、ETag、Last-Modified
3. 尝试添加 ?nocache=1 或时间戳参数绕过缓存
4. 如果加参数后正常，说明是缓存问题

常见缓存层：
- 浏览器缓存
- CDN 缓存
- Nginx 缓存
- 后端应用缓存（Redis 等）

解决方案：
- 临时：URL 加随机参数 ?t=${Date.now()}
- 永久：调整后端 Cache-Control 响应头

---

## Token 存储问题排查

典型场景：登录成功后立即调用接口返回 401

排查步骤：
1. 确认前端正确传递 Token（检查 Request Headers）
2. 检查 Nacos 配置中 iam.token.storage.type 设置
3. 确认 Gateway 和 IAM 服务使用相同的存储方式

关键配置：
- iam.token.storage.type=redis -> Token 存 Redis
- iam.token.storage.type=database -> Token 存数据库
- Gateway 默认从 Redis 读取 Token

解决方案：确保 IAM 和 Gateway 配置一致，推荐使用 redis

---

## BUG 文档维护规范

BUG 修复后必须更新 BUG 文档，记录修复详情。

BUG 文档位置：
- 位于项目的 .kiro/bugs/ 目录下

文档内容要求：
```
修复详情
- 修复时间：YYYY-MM-DD
- 修复人：Kiro AI
- 修改的文件：
  1. path/to/file1.java - 修改说明
  2. path/to/file2.java - 修改说明
- 修复方案：简要描述修复逻辑
- 验证结果：测试通过/待验证

状态: 已修复
```

---

最后更新：2026-01-03
