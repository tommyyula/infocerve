---
inclusion: manual
---

# 线上问题排查指南

---

## 核心原则

BUG 排查 = 需求开发，必须遵循复杂开发流程：

```
阶段1：问题澄清 -> research_mode + process_thought -> 分析可能原因
阶段2：确认方案 -> 与用户确认问题原因 -> 得到确认后再修改
阶段3：执行修复 -> 修改代码 -> 验证修复效果
```

---

## 排查原则（必须遵守）

[重要] 禁止猜测
- 不能根据文档示例、历史记录推断实际配置

[重要] 先确认再改
- 任何代码修改前必须与用户确认

[重要] 查实际数据
- 用数据库查询、日志、API 响应验证假设

[重要] 不确定就问
- 无法验证时直接询问用户

[重要] 用 MCP 前先问
- 使用 mysql_query 前先问用户用哪个数据库

---

## 结论验证原则（反证法）

在得出"配置错误"或"代码缺陷"结论前，必须执行反证法检验：

1. 识别依赖关系：找出依赖同一配置/代码的其他功能
2. 检查功能状态：这些功能是否正常工作？
3. 逻辑验证：
   - 其他功能正常 -> 配置/代码本身没问题 -> 排除该假设
   - 其他功能也异常 -> 可能是配置/代码问题 -> 继续验证

---

## 数据库问题排查

发现不一致时，禁止假设任何一方是"正确的"：

1. 收集信息：DDL 脚本、DESCRIBE 实际结构、代码实体定义
2. 对比差异：列出所有不一致的地方
3. 列出可疑点：不做假设，把所有可能性都列出来
4. 询问用户：让用户确认设计意图

给出初步分析帮助用户判断：
- 从业务逻辑角度分析
- 从代码逻辑角度分析
- 从注释/文档角度分析
- 给出推荐方案

---

## 500 错误排查流程

步骤 1：尝试获取日志
- 询问用户是否能提供后端日志
- 如果能获取，直接从日志定位问题

步骤 2：无日志时的代码分析（必须使用 task-manager）
```
1. research_mode - 梳理完整调用链，识别所有可能的异常点
2. process_thought - 逐个分析每个异常点的触发条件
3. 产出结论报告 - 列出所有可能原因并排序
4. 与用户确认 - 确认最可能的原因
5. 确认后修改 - 得到用户确认后再修改代码
```

---

## 常见问题速查

401 Unauthorized
- 可能原因：Token 存储不一致
- 排查方向：检查 Nacos 配置

404 Not Found
- 可能原因：API 路径错误
- 排查方向：检查前端部署版本

500 Internal Error
- 可能原因：后端异常
- 排查方向：查看日志或代码分析

数据不更新/显示旧数据
- 可能原因：浏览器缓存
- 排查方向：URL 加 ?nocache=1

---

## 缓存问题排查

快速验证方法：
```
在请求 URL 后添加 ?nocache=1 参数
```

排查步骤：
1. 在浏览器 Network 面板查看请求
2. 检查 Response Headers 中的缓存相关头
3. 尝试添加 ?nocache=1 绕过缓存
4. 如果加参数后正常，说明是缓存问题

常见缓存层：
- 浏览器缓存
- CDN 缓存
- Nginx 缓存
- 后端应用缓存（Redis 等）

---

## Token 存储问题排查

典型场景：登录成功后立即调用接口返回 401

排查步骤：
1. 确认前端正确传递 Token
2. 检查 Nacos 配置中 iam.token.storage.type 设置
3. 确认 Gateway 和 IAM 服务使用相同的存储方式

关键配置：
- iam.token.storage.type=redis -> Token 存 Redis
- iam.token.storage.type=database -> Token 存数据库

---

## BUG 文档维护

修复后更新 .kiro/bugs/ 目录下的文档：

```
修复详情
- 修复时间：YYYY-MM-DD
- task-manager 任务ID：xxx
- 修改的文件：
  1. path/to/file.java - 修改说明
- 修复方案：简要描述
- 验证结果：verify_task 评分

状态: 已修复
```

